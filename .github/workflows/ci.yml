name: CI

on:
  pull_request:
    paths-ignore:
      - "**/*.md"
      - "docs/**"
  schedule:
    - cron: "0 8 * * 1"
  workflow_dispatch:
    inputs:
      run_coverage:
        description: "Run llvm-cov coverage job"
        required: false
        default: false
        type: boolean
      run_cross_platform:
        description: "Run cross-platform compile smoke jobs"
        required: false
        default: false
        type: boolean

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: read
  pull-requests: read

env:
  CARGO_TERM_COLOR: always

jobs:
  quality-linux:
    name: Quality (fmt + clippy + tests)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      run_coverage: ${{ steps.quality_mode.outputs.run_coverage }}
      run_cross_platform: ${{ steps.quality_mode.outputs.run_cross_platform }}
      heavy_reason: ${{ steps.quality_mode.outputs.heavy_reason }}
      rust_changed: ${{ steps.rust_scope.outputs.rust_changed }}
      run_wasm_smoke: ${{ steps.wasm_scope.outputs.wasm_smoke_needed }}
    steps:
      - name: Checkout (attempt 1)
        id: checkout_attempt_1
        uses: actions/checkout@v6
        continue-on-error: true

      - name: Backoff before checkout retry 2
        if: steps.checkout_attempt_1.outcome == 'failure'
        shell: bash
        run: sleep 3

      - name: Checkout (attempt 2)
        id: checkout_attempt_2
        if: steps.checkout_attempt_1.outcome == 'failure'
        uses: actions/checkout@v6
        continue-on-error: true

      - name: Backoff before checkout retry 3
        if: steps.checkout_attempt_1.outcome == 'failure' && steps.checkout_attempt_2.outcome == 'failure'
        shell: bash
        run: sleep 6

      - name: Checkout (attempt 3)
        id: checkout_attempt_3
        if: steps.checkout_attempt_1.outcome == 'failure' && steps.checkout_attempt_2.outcome == 'failure'
        uses: actions/checkout@v6
        continue-on-error: true

      - name: Evaluate checkout retry outcomes
        id: checkout_retry_report
        if: always() && (steps.checkout_attempt_1.outcome == 'success' || steps.checkout_attempt_2.outcome == 'success' || steps.checkout_attempt_3.outcome == 'success')
        shell: bash
        run: |
          set -euo pipefail
          attempt_1="${{ steps.checkout_attempt_1.outcome }}"
          attempt_2="${{ steps.checkout_attempt_2.outcome }}"
          attempt_3="${{ steps.checkout_attempt_3.outcome }}"
          if [[ -z "${attempt_2}" ]]; then
            attempt_2="skipped"
          fi
          if [[ -z "${attempt_3}" ]]; then
            attempt_3="skipped"
          fi

          python3 .github/scripts/ci_checkout_retry.py \
            --outcomes "${attempt_1},${attempt_2},${attempt_3}" \
            --max-attempts 3 \
            --base-delay-seconds 3 \
            --cap-delay-seconds 6 \
            --max-total-delay-seconds 12 \
            --summary "$GITHUB_STEP_SUMMARY" \
            --output "$GITHUB_OUTPUT"

      - name: Fail when checkout retries are exhausted
        if: steps.checkout_attempt_1.outcome != 'success' && steps.checkout_attempt_2.outcome != 'success' && steps.checkout_attempt_3.outcome != 'success'
        shell: bash
        run: |
          set -euo pipefail
          attempt_1="${{ steps.checkout_attempt_1.outcome }}"
          attempt_2="${{ steps.checkout_attempt_2.outcome }}"
          attempt_3="${{ steps.checkout_attempt_3.outcome }}"
          if [[ -z "${attempt_2}" ]]; then
            attempt_2="skipped"
          fi
          if [[ -z "${attempt_3}" ]]; then
            attempt_3="skipped"
          fi

          echo "::error::checkout failed after 3 bounded attempts; mode=checkout_retries_exhausted; outcomes=${attempt_1},${attempt_2},${attempt_3}"
          {
            echo "### Checkout Retry"
            echo "- Status: failure"
            echo "- Mode: checkout_retries_exhausted"
            echo "- Outcomes: ${attempt_1},${attempt_2},${attempt_3}"
            echo "- Max attempts: 3"
            echo "- Retry delays (s): [3, 6]"
            echo "- Planned total delay (s): 9"
          } >> "$GITHUB_STEP_SUMMARY"
          exit 1

      - name: Detect change scope
        id: change_scope
        if: github.event_name == 'pull_request'
        uses: dorny/paths-filter@v3
        with:
          filters: |
            heavy:
              - "crates/tau-coding-agent/**"
              - "crates/tau-agent-core/**"
              - "crates/tau-ai/**"
              - "Cargo.toml"
              - "Cargo.lock"
              - ".github/workflows/**"
              - ".github/scripts/**"
            rust:
              - "**/*.rs"
              - "**/Cargo.toml"
              - "Cargo.toml"
              - "Cargo.lock"
            helpers:
              - ".github/workflows/**"
              - ".github/scripts/**"
            fast_validate:
              - "scripts/dev/fast-validate.sh"
              - "scripts/dev/test-fast-validate.sh"
            release_helpers:
              - "scripts/release/**"
              - ".github/workflows/release.yml"
            wasm_smoke:
              - "crates/kamn-core/**"
              - "crates/kamn-sdk/**"
              - "crates/tau-access/**"
              - "crates/tau-deployment/**"
              - "crates/tau-cli/**"
              - "crates/tau-startup/**"
              - "crates/tau-onboarding/**"
              - "scripts/dev/wasm-smoke.sh"
              - "scripts/dev/test-wasm-smoke.sh"
              - "scripts/edge/**"
              - ".github/workflows/ci.yml"

      - name: Determine rust scope
        id: rust_scope
        shell: bash
        run: |
          set -euo pipefail
          rust_changed="${{ steps.change_scope.outputs.rust }}"
          if [[ "${{ github.event_name }}" != "pull_request" ]]; then
            rust_changed="true"
          elif [[ -z "${rust_changed}" ]]; then
            rust_changed="false"
          fi
          echo "rust_changed=${rust_changed}" >> "$GITHUB_OUTPUT"
          echo "### Rust Scope" >> "$GITHUB_STEP_SUMMARY"
          echo "- Rust/Cargo changed: ${rust_changed}" >> "$GITHUB_STEP_SUMMARY"

      - name: Determine helper test scope
        id: helper_scope
        shell: bash
        run: |
          set -euo pipefail
          helper_tests_needed="${{ steps.change_scope.outputs.helpers }}"
          if [[ "${{ github.event_name }}" != "pull_request" ]]; then
            helper_tests_needed="true"
          elif [[ -z "${helper_tests_needed}" ]]; then
            helper_tests_needed="false"
          fi
          echo "helper_tests_needed=${helper_tests_needed}" >> "$GITHUB_OUTPUT"
          echo "### Helper Tests" >> "$GITHUB_STEP_SUMMARY"
          echo "- Helper tests needed: ${helper_tests_needed}" >> "$GITHUB_STEP_SUMMARY"

      - name: Validate CI helper scripts
        if: steps.helper_scope.outputs.helper_tests_needed == 'true'
        run: python3 -m unittest discover -s .github/scripts -p "test_*.py"

      - name: Check roadmap status sync blocks
        env:
          GH_TOKEN: ${{ github.token }}
        run: scripts/dev/roadmap-status-sync.sh --check

      - name: Check rust doc density thresholds
        if: steps.rust_scope.outputs.rust_changed == 'true'
        run: |
          python3 .github/scripts/rust_doc_density.py \
            --repo-root . \
            --targets-file docs/guides/doc-density-targets.json

      - name: Determine fast-validate script scope
        id: fast_validate_scope
        shell: bash
        run: |
          set -euo pipefail
          fast_validate_tests_needed="${{ steps.change_scope.outputs.fast_validate }}"
          if [[ "${{ github.event_name }}" != "pull_request" ]]; then
            fast_validate_tests_needed="true"
          elif [[ -z "${fast_validate_tests_needed}" ]]; then
            fast_validate_tests_needed="false"
          fi
          echo "fast_validate_tests_needed=${fast_validate_tests_needed}" >> "$GITHUB_OUTPUT"
          echo "### fast-validate Scope" >> "$GITHUB_STEP_SUMMARY"
          echo "- fast-validate tests needed: ${fast_validate_tests_needed}" >> "$GITHUB_STEP_SUMMARY"

      - name: Validate fast-validate script
        if: steps.fast_validate_scope.outputs.fast_validate_tests_needed == 'true'
        run: ./scripts/dev/test-fast-validate.sh

      - name: Determine release-helper scope
        id: release_helper_scope
        shell: bash
        run: |
          set -euo pipefail
          release_helper_tests_needed="${{ steps.change_scope.outputs.release_helpers }}"
          if [[ "${{ github.event_name }}" != "pull_request" ]]; then
            release_helper_tests_needed="true"
          elif [[ -z "${release_helper_tests_needed}" ]]; then
            release_helper_tests_needed="false"
          fi
          echo "release_helper_tests_needed=${release_helper_tests_needed}" >> "$GITHUB_OUTPUT"
          echo "### Release Helper Scope" >> "$GITHUB_STEP_SUMMARY"
          echo "- release helper tests needed: ${release_helper_tests_needed}" >> "$GITHUB_STEP_SUMMARY"

      - name: Validate release install/update helper scripts
        if: steps.release_helper_scope.outputs.release_helper_tests_needed == 'true'
        run: |
          ./scripts/release/test-install-helpers.sh
          ./scripts/release/test-release-workflow-contract.sh

      - name: Determine wasm smoke scope
        id: wasm_scope
        shell: bash
        run: |
          set -euo pipefail
          wasm_smoke_needed="${{ steps.change_scope.outputs.wasm_smoke }}"
          if [[ "${{ github.event_name }}" != "pull_request" ]]; then
            wasm_smoke_needed="true"
          elif [[ -z "${wasm_smoke_needed}" ]]; then
            wasm_smoke_needed="false"
          fi
          echo "wasm_smoke_needed=${wasm_smoke_needed}" >> "$GITHUB_OUTPUT"
          echo "### WASM Smoke Scope" >> "$GITHUB_STEP_SUMMARY"
          echo "- WASM smoke needed: ${wasm_smoke_needed}" >> "$GITHUB_STEP_SUMMARY"

      - name: Validate wasm-smoke scripts
        if: steps.wasm_scope.outputs.wasm_smoke_needed == 'true'
        run: ./scripts/dev/test-wasm-smoke.sh

      - name: Determine quality mode
        id: quality_mode
        shell: bash
        run: |
          set -euo pipefail
          heavy_changed="${{ steps.change_scope.outputs.heavy }}"
          if [[ -z "${heavy_changed}" ]]; then
            heavy_changed="false"
          fi
          coverage_requested="${{ inputs.run_coverage }}"
          if [[ -z "${coverage_requested}" ]]; then
            coverage_requested="false"
          fi
          cross_platform_requested="${{ inputs.run_cross_platform }}"
          if [[ -z "${cross_platform_requested}" ]]; then
            cross_platform_requested="false"
          fi
          python3 .github/scripts/ci_quality_mode.py \
            --event-name "${{ github.event_name }}" \
            --head-ref "${{ github.head_ref }}" \
            --heavy-changed "${heavy_changed}" \
            --run-coverage "${coverage_requested}" \
            --run-cross-platform "${cross_platform_requested}" \
            --output "$GITHUB_OUTPUT" \
            --summary "$GITHUB_STEP_SUMMARY"

      - name: Install Rust (full lane)
        if: steps.rust_scope.outputs.rust_changed == 'true' && steps.quality_mode.outputs.mode != 'codex-light'
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Install Rust (codex-light lane)
        if: steps.rust_scope.outputs.rust_changed == 'true' && steps.quality_mode.outputs.mode == 'codex-light'
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: Cache Cargo
        if: steps.rust_scope.outputs.rust_changed == 'true'
        uses: Swatinem/rust-cache@v2

      - name: Check formatting
        if: steps.rust_scope.outputs.rust_changed == 'true' && steps.quality_mode.outputs.mode == 'codex-light'
        run: cargo fmt --all --check

      - name: Verify unsafe-free policy
        if: steps.rust_scope.outputs.rust_changed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if rg -n --glob '!**/target/**' '\bunsafe\s+fn\b|\bunsafe\s*\{' crates; then
            echo "::error::unsafe Rust blocks/functions are prohibited by repository policy"
            exit 1
          fi

      - name: Validate Rust scope (full lane)
        if: steps.rust_scope.outputs.rust_changed == 'true' && steps.quality_mode.outputs.mode != 'codex-light'
        env:
          RUST_MIN_STACK: "8388608"
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            git fetch --no-tags --depth=1 origin "${{ github.event.pull_request.base.sha }}" || true
            ./scripts/dev/fast-validate.sh --base "${{ github.event.pull_request.base.sha }}"
          else
            ./scripts/dev/fast-validate.sh --full
          fi

      - name: Lint (codex-light lane)
        if: steps.rust_scope.outputs.rust_changed == 'true' && steps.quality_mode.outputs.mode == 'codex-light'
        run: cargo check -p tau-coding-agent --all-targets

      - name: Report lint strategy
        shell: bash
        run: |
          echo "### Lint Strategy" >> "$GITHUB_STEP_SUMMARY"
          if [[ "${{ steps.rust_scope.outputs.rust_changed }}" != "true" ]]; then
            echo "- Mode: skipped" >> "$GITHUB_STEP_SUMMARY"
            echo "- Reason: no Rust/Cargo changes in pull_request scope" >> "$GITHUB_STEP_SUMMARY"
          elif [[ "${{ steps.quality_mode.outputs.mode }}" == "codex-light" ]]; then
            echo "- Mode: codex-light" >> "$GITHUB_STEP_SUMMARY"
            echo "- Command: cargo check -p tau-coding-agent --all-targets" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "- Mode: full" >> "$GITHUB_STEP_SUMMARY"
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              echo "- Command: ./scripts/dev/fast-validate.sh --base <pull_request.base.sha>" >> "$GITHUB_STEP_SUMMARY"
              echo "- Scope: impacted crates (changed crates + workspace reverse dependencies)" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "- Command: ./scripts/dev/fast-validate.sh --full" >> "$GITHUB_STEP_SUMMARY"
              echo "- Scope: full workspace" >> "$GITHUB_STEP_SUMMARY"
            fi
          fi

      - name: Run codex light demo smoke
        if: steps.rust_scope.outputs.rust_changed == 'true' && steps.quality_mode.outputs.mode == 'codex-light'
        env:
          RUST_MIN_STACK: "8388608"
        run: |
          python3 .github/scripts/demo_smoke_runner.py \
            --repo-root . \
            --manifest .github/demo-smoke-manifest.json \
            --binary target/debug/tau-coding-agent \
            --log-dir ci-artifacts/demo-smoke \
            --summary "$GITHUB_STEP_SUMMARY" \
            --build

      - name: Upload codex light demo smoke logs
        if: always() && steps.rust_scope.outputs.rust_changed == 'true' && steps.quality_mode.outputs.mode == 'codex-light'
        uses: actions/upload-artifact@v6
        with:
          name: demo-smoke-logs
          path: ci-artifacts/demo-smoke
          if-no-files-found: ignore

  wasm-smoke:
    name: WASM compile smoke
    needs: [quality-linux]
    if: needs.quality-linux.outputs.run_wasm_smoke == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 25
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install Rust + wasm target
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2

      - name: Run wasm smoke harness
        run: ./scripts/dev/wasm-smoke.sh

  cross-platform-smoke:
    name: Cross-platform compile smoke (${{ matrix.name }})
    needs: [quality-linux]
    if: |
      always() && (
        (
          github.event_name == 'workflow_dispatch' &&
          (inputs.run_cross_platform == true || inputs.run_cross_platform == 'true')
        ) ||
        (
          needs.quality-linux.result == 'success' &&
          needs.quality-linux.outputs.run_cross_platform == 'true'
        )
      )
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: macos-amd64
            os: macos-latest
            target: x86_64-apple-darwin
          - name: windows-amd64
            os: windows-latest
            target: x86_64-pc-windows-msvc
          - name: windows-arm64
            os: windows-latest
            target: aarch64-pc-windows-msvc
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2

      - name: Compile release target smoke
        run: cargo build --release -p tau-coding-agent --target ${{ matrix.target }}

  coverage:
    name: Coverage (llvm-cov)
    runs-on: ubuntu-latest
    if: needs.quality-linux.outputs.run_coverage == 'true'
    outputs:
      line_coverage: ${{ steps.coverage.outputs.line_coverage }}
    needs: [quality-linux]
    env:
      COVERAGE_MIN: "60.0"
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-llvm-cov

      - name: Generate coverage report
        id: coverage
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p coverage
          cargo llvm-cov --workspace --all-features --summary-only --lcov --output-path coverage/lcov.info | tee coverage/summary.txt

          coverage_pct=$(awk '/^TOTAL/{gsub(/%/,"",$NF); print $NF}' coverage/summary.txt)
          if [[ -z "${coverage_pct}" ]]; then
            echo "::error::failed to parse TOTAL coverage percentage"
            exit 1
          fi

          echo "line_coverage=${coverage_pct}" >> "$GITHUB_OUTPUT"
          awk -v coverage="${coverage_pct}" -v minimum="${COVERAGE_MIN}" 'BEGIN { if (coverage + 0 < minimum + 0) exit 1 }'

      - name: Coverage summary
        run: |
          echo "### Coverage" >> "$GITHUB_STEP_SUMMARY"
          echo "- Line coverage: ${{ steps.coverage.outputs.line_coverage }}%" >> "$GITHUB_STEP_SUMMARY"
          echo "- Minimum threshold: ${COVERAGE_MIN}%" >> "$GITHUB_STEP_SUMMARY"

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v6
        with:
          name: coverage-report
          path: |
            coverage/lcov.info
            coverage/summary.txt
